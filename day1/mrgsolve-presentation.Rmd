---
title: "Introduction to mrgsolve"
date: ''
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: false
    css: style.css
editor_options:
  chunk_output_type: console
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(message = FALSE)
options(mrgsolve.soloc = "build")
```


```{r, include = FALSE}
library(here)
source(here("day1/src/global.R"))
library(mrgsolve)
library(dplyr)
library(knitr)
library(lattice)
tryit_file <- "workbook.Rmd"
```

```{r setup, echo = FALSE, message = FALSE}
mod <- mread_cache("pk1", modlib()) %>% 
  update(end = 192, delta = 0.2) %>% Req(CP)
data(exidata)
data <- filter(exidata, ID <= 10)
set.seed(1222)
```

# What can you do with mrgsolve?

```{r, echo = FALSE, fig.width = 6, fig.height = 5}
mod %>% ev(amt = 100) %>% mrgsim(end = 72) %>% plot()
```


```{r, echo = FALSE, fig.width = 6, fig.height = 5}
mod %>% ev(amt = 100, ii = 24, addl = 4) %>% mrgsim() %>% plot()
```


```{r, echo = FALSE, message=FALSE, fig.width = 6, fig.height = 5}
mod <- mread_cache("popex", modlib()) %>% Req(DV)
data <- expand.ev(amt = 300, ii = 24, addl = 4, ID = seq(20))
mod %>% data_set(data) %>% mrgsim() %>% plot()
```


```{r, echo = FALSE, fig.width = 6, fig.height = 5}
hmod <- mrgsolve:::house() %>% Req(DV,RESP) %>% update(end = 244)
hdat <- mutate(data, time = 24)
mrgsim(hmod, data = hdat, omega = dmat(0.1,0.1,0.1,0.1)) %>% plot()
```


```{r, echo = FALSE, fig.width = 6, fig.height = 5}
idata <- tibble(VC = c(20,60,180))
hmod %>% mrgsim(idata = idata,  end = 24*28, delta = 0.1,
                events = ev(amt = 100, ii = 24, addl = 28)) %>%
  plot(DV~.)
```



```{r, echo = FALSE, message = FALSE, warning=FALSE, fig.width = 6, fig.height = 5}
mod <- mread_cache("conway", .day1("model"))
e <- ev(amt = 1, evid = 8, time = 180) + ev(amt = 0, evid = 8, time = 2.5*365)
idata <- tibble(L_0 = c(1,3,5,7,10))
out <- mrgsim(mod, events = e, idata = idata, end = 6*365, delta = 1)
out@data <- mutate(out@data, time = time - 180)
plot(out, L+logV~(time/365), xlab = "Time (year)")
```


# About `mrgsolve` 

- `R` package for simulation from ODE-based models
    - Free, OpenSource, GitHub, CRAN
- Language
    - Models written in `C++` inside model specification format
    - General purpose solver: `ODEPACK` / `DLSODA` (`FORTRAN`)
        - Automatically detect and switch between non-stiff (Adams) and stiff (BDF)
          methods for solving the differential equations
    - Simulation workflow in `R`
- Hierarchical (population) simulation
    - `ID`, $\eta$, $\varepsilon$
- Integrated PK functionaility
    - Bolus, infusion, `F`, `ALAG`, `SS` etc, handled under the hood
    - 1- and 2-cmt PK models in closed-form
- Extensible using `R`, `C++`, `Rcpp`, `boost`, `RcppArmadillo`
- `R` is it's natural habitat

# `mrgsolve` started as `QSP` modeling tool
- Motivation: large bone/mineral homeostatsis model (CaBone)
- History using
    - Berkeley Madonna
    - WinBUGS
    - NONMEM (attempted)
- 2010: write `R` front end to `deSolve`
- 2012: write `C++` interface to `DLSODA`
- Develop dosing / event capability
- More recently, expose functionality provided by
    - `Rcpp` - vectors, matrices, functions, environments, random numbers 
    - `boost` - numerical tools in `C++`
    - users' own `C++` code (functions, data structures, classes)
- Translator from `SBML` to `mrgsolve` using `R` bindings to `libSBML`   


# Orientation

- https://CRAN.R-project.org/package=mrgsolve

- GitHub site: https://github.com/metrumresearchgroup/mrgsolve

- Discussion: https://github.com/metrumresearchgroup/mrgsolve/discussions

- Issues: https://github.com/metrumresearchgroup/mrgsolve/issues

- mrgsolve website: https://mrgsolve.org

- User Guide: https://mrgsolve.org/user_guide

- Blog: https://mrgsolve.org/blog

- Vignettes: https://mrgsolve.org/vignettes

# R for Data Science

https://r4ds.had.co.nz/


# What we will cover today

1. Three basic workflows
1. Loading the model into R
1. Event objects
1. Data sets
1. Model specification - code together
1. Whatever you ask about


---

```{r setup-1, echo = FALSE, message = FALSE}
mod <- mread_cache("pk1", modlib()) %>% 
  update(end = 192, delta = 0.2) %>% 
  Req(CP)
data(exidata)
data <- filter(exidata, ID <=10)
set.seed(1222)
```

# A basic simulation with mrgsolve
```{r, fig.width = 6, fig.height = 5}
mod %>% ev(amt = 100, ii = 24, addl = 3) %>% mrgsim() %>% plot()
```


# A basic simulation with mrgsolve

```{r, eval = FALSE, fig.width = 6, fig.height = 5}
mod %>% ev(amt = 100, ii = 24, addl = 3) %>% mrgsim() %>% plot()
```

- <red>mod</red>: the model object
    - Ok ... where did `that` come from?
- <blu>ev(amt = 100, ...)</blu> : the intervention
    - An `event` in this example
- <grn>mrgsim()</grn>: actually do the simulation
- <orng>plot()</orng>: do something with the simulation
    - `plot`, `mutate`, `as_tibble` etc ... 


> - <red>model</red> `%>%` <blu>intervention</blu> `%>%` <grn>Go!</grn> `%>%` <orng>take-a-look</orng> 

# What's coming ...

> - `model %>% intervention %>%` <alrt>options</alrt> `%>% Go! %>% ...`

> - `model %>% intervention %>%` <orng>population</orng> `%>% Go! %>% ...`

> - `model %>%` <purp>data-set</purp> `%>% Go! %>% ...`

> - where <purp>data-set</purp> = `intervention + population`

> - For now, let's get this part down 

> - <red>model</red> `%>%` <blu>intervention</blu> `%>%` <grn>Go!</grn> `%>%` <orng>take-a-look<orng> 


# Why do we use `%>%` ?

What happens first in this operation?

```{r, eval = FALSE}
mean(sqrt(seq(4)))
```

# Pipelines

```{r, eval = FALSE}
mean(sqrt(seq(4)))
```

```{r, eval = FALSE}
4  %>% seq() %>% sqrt() %>% mean()
```

Better.

```{r, eval = FALSE}
4  %>% 
  seq(.) %>% 
  sqrt(.) %>% 
  mean(., na.rm = TRUE)
```

```{r,eval = FALSE}
mod %>% some_intervention() %>% simulate() %>% post_process()
```


# The model object

<red>mod</red><blk>el</blk> `%>% ... `

> - I (almost) always call the model object <red>mod</red> in the documention / examples

> - All the information about the model we need to know to run the simulation

> - <grn>Distinct</grn> from the intervention, the population, the summary

> - But the model <orng>does</orng> know  about output time, random effects


# Take a look: overview

```{r, comment = ""}
mod
```

# Take a look: parameters (<red>really important</red>)
```{r, comment = ""}
param(mod)
```

> - Parameters get a name
> - Names and number of parameters gets fixed at compile time
> - All parameters have a value
> - Value can be modified after compile time

# Take a look: compartments
```{r, comment = ""}
init(mod)
```

> - Every compartment gets a name
> - Every compartment gets an initial condition

